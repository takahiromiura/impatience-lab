# Python チュートリアル

 実行するとエラーになるものは、`#` でコメントアウトしています。
 実行するときは、`#` を外してください。
 ここでは、Python の基本的な文法などを見ていきます。
 まずは、お馴染みの。

```py
print('Hello World!')
```

 実はこの 1 行に Python のエッセンスが詰まっています。
 C などの言語では、先程の文を出すには 3 行ほど必要なのですが、その時にいろいろな **おまじない** を書かなければいけません。
 Python では、こうしたおまじないを極力書かないで済むので、自分がどういった操作をしているかが分かりやすく、学習が容易になるのです。
 Python を起動すると、**組み込み型**という基本的な型が使えます。
 型ごとに持っている機能が異なります。
 例えば、整数を扱うための型、文字列を扱うための型、その他にも様々な型があります。
 また、整数型、文字列型、関数などを全てを総称して ``オブジェクト`` といいます。
 まずは、**組み込み型** を学んで、Python に慣れていきましょう。

## 変数

 さて、組み込み型を説明する前に、変数について説明しましょう。
 変数には数字や文字などを格納することができます。
 例えば、 `apple = 100` とすれば、 `apple` に 100 という値が格納されます。
 数字を変数名の最初にすることは許されていません@。
apple = 100
 変数の中身を呼び出すには、変数名をタイプします。
apple
 何も格納していない変数を参照した場合は、エラーが返ってきます。
 例えば、次を実行すると、`NameError` が返ってきます。

# orange

## エラー

 プログラミングをしていく中で、エラーは必ず起こります。
 ですが、エラーが出たからといって、気落ちしないでください。
 エラーが起きたら、エラーの内容をよく読んでみましょう。
 例えば、先の場合は、`NameError: name 'orange' is not defined` という内容です。
 これは、`orange` という変数はまだ定義されていませんということです。
 それでは、次に `orange = 150` と打ってみてから、`orange`を参照してみましょう。今度はエラーが出ないはずです。
orange = 150
orange
 エラーの内容を読んでもよくわからなかった場合、エラーの内容をコピーして、ググりましょう。
 プログラミングに関する Q & A ウェブサイトとして、[stack overflow](https://stackoverflow.com/) が有名です。
 ほとんどの場合、こちらを参照すれば同じような問題を抱えた人がいて、それに対する答えも提供されていることでしょう（基本的に英語です）。
 また、 [teratail](https://teratail.com/) という日本のサイトもあります。
 調べても答えが得られなかった場合は、上記の2つで質問してみるのもよいでしょう。
 他にも、モジュールの使い方がいまいちわからない場合、 [Qiita](http://qiita.com/) で検索してみましょう。
 そのモジュールを使用した記事があるかもしれません。

## 基本的な型

### int (整数）型

 整数型は値に整数を持ちます。
 あまり説明する必要はないかもしれません。
 次の例は整数型です。
1

### float (小数点) 型

 小数点型は値に小数点を持ちます。
 整数の後に `.` をつけることで小数点型になります。
 次の例は小数点型です。
1.0

### 基本的な演算子

 Python では四則演算、累乗、剰余は次のように行います。

* 加算: `+`
* 減算: `-`
* 乗算: `*`
* 除算: `/`
* 累乗: `**`
* 剰余: `%`
1 + 1
3 - 2
4 * 7
8 / 3
2 ** 4
6 % 2

### str (文字列) 型

 文字列型は値に文字列を持ちます。
 文字列の前後を シングルクォート ` かダブルクォート "  で囲みます。
 次の例は文字列型です。
'string'
 文字列は足すことができます。
 しかし、引くことはできません。
'str' + 'ing'

# 'string' - 'ing'

### list (リスト)

 リストは複数の値を持つことができます。リストを作るには、かぎかっこ `[]` を使います。
 複数の要素を持つリストを作る場合は、各要素を `,` で分けます。
[1, 2, 3]
 リストの中には、異なる型を入れられます。
[1, 3.14, 'string']
 リストとリストは足すことができますが、引くことはできません。
[1, 2, 3] + [4, 5, 6]
 リストの各要素を参照するには、かぎかっこ `[]` を用い、かぎかっこの中に参照したい要素の番号（インデックス）を入れます。
 R とは違い、 Python では、要素の番号は 0 から始まります（ R では 1 から）。
 リストにない番号を参照するとエラーが返ってきます。
num_list = [1, 2, 3]
num_list
num_list[0]

# num_list[4]

 マイナスの番号を入れると、後ろから参照します。
num_list[-1]

### dict (辞書) 型

 辞書は、キーと値をセットで使います。辞書を作るには、なみかっこ `{}` を使います。
 `{キー：値}` という順番で各要素を作成します。
 複数のキーと値を持つ辞書を作る場合は、各要素を `,` で分けます。
{'apple': 100, 'orange': 150}
 辞書の要素を参照するには、`[]` を用います。
 `[]` の中にキーとなる値を入れると、そのキーに対応する値が返ってきます。
 キー以外の値を参照しようとすると、エラーが返ってきます。
fruits = {'apple': 100, 'orange': 150}
fruits
fruits['apple']

# fruits['melon']

 新たにキーと値を追加するには、`辞書[キー] = 値` とします。
fruits['melon'] = 500
fruits['melon']

### tuple (タプル)

 タプルはリストと同じように複数の要素を持つことができます。
 また、各要素の参照もリストと同じです。
 しかし、リストと違うのは、要素の追加、削除、編集ができないということです。
 意図せず値を書き換えてしまうことを防ぎたい場合は、タプルを使うとよいでしょう。
car = ('taxi', 'bus')
car
car[0]

# car[0] = 'truck'

 ちなみに、要素が 1 つのみのタプルを作るときには、`(i, )` とします。

### スライス

 リスト、タプルなどで、複数の要素を参照したい場合は、*スライス* を使います。
 i 番目の要素を参照するには、`[i]` でしたが、  `[i:j]` とすると、i 番目から j - 1 番目までの要素を参照します。
 以下はリストの参照の例です。
num_list = [1, 2, 3]
num_list
num_list[0:2]
 k 番目からの要素を全て参照する場合には、`[k:]` とします。
num_list[1:]
 逆に、0 番目から k - 1 番目までを参照するには、`[:k]` とします。
num_list[:2]

  `[:]` は全ての要素を返します。
num_list[:]
 ちなみに、文字列もインデックスが振られているので、文字列の一部のみを参照することができます。
'string'[:3]

## メソッド (Method)

 オブジェクトには、固有の関数が用意されています。これをメソッドといいます。
 文字列型には例えば、次のようなメソッドが用意されています。

* `lower`: 文字列を小文字にする
* `upper`: 文字列を大文字にする
* `split`: 文字列を指定した境界にしたがって、分割し、リストを作る

 リスト型には例えば、次のようなメソッドが用意されています。

* `append`: リストに要素を追加する
* `extend`: リストにリストを追加する
* `remove`: 指定した値をリストから除外する

 メソッドを使うには、型を作成し、`オブジェクト.メソッド(引数)` とします。例を見てみましょう。
jp = 'japan'
jp.upper()
JP = 'JAPAN'
JP.lower()
countries = 'japan,korea,america'
countries.split(',')
odd_num = [1, 3, 5]
odd_num
odd_num = [1, 3, 5]
odd_num.append(7)
odd_num
odd_num.extend([9, 11])
odd_num
odd_num.remove(5)
odd_num
 メソッドには破壊的メソッドと非破壊的メソッドがあります。
 破壊的メソッドは、メソッドを呼び出したオブジェクトの値そのものを変更します。
 一方、非破壊的メソッドは、新たなオブジェクトを返します。
 例えば、``lower``, ``upper``, ``split`` は非破壊的メソッド、``append``, ``extend``, ``remove`` は破壊的メソッドです。
 引数が必要でない場合も、`()` を忘れると、関数の戻り値ではなく関数自体が返ってきますので注意してください。
jp.upper
 これまでに、いくつかの基本的な型を説明してきました。
 各オブジェクトには様々な特徴があり、またそれぞれ固有の関数（メソッド）を持っています。
 くぎを打つ場合には金づちを使い、木を切る場合にはのこぎりを使います。
 同じように、使用目的によって、型を使い分けることが重要です。

## ループ文

 似たような操作を繰り返したい場合、例えば、1 から 10 までの整数を順に出力したい場合などには、ループ文を使うとよいでしょう。
 Python では、 `for`, `while` がよく用いられます。1 つずつその性質を見ていきましょう。

### for

 `for` は、リストやタプルなどからその中の要素を逐次的に引き出す場合に使われます。
 例えば、次のようにします。
for i in [1, 2, 3]:
    print(i)

 `print` はその名の通り、`()` 内の値を出力したい場合に用いる関数です。
 上の文では、`i` にリスト `[1, 2, 3]` の各要素が順に代入されていきます。
 Python では、他のプログラミング言語と違い、**インデント（字下げ）** が意味を持ちます。
 ループや、関数、クラスの定義の際には、直下のインデントした文がループ文、関数、クラスの定義の文になります。
 詳しく見てみましょう。
j = 0
k = 0
for i in [1, 2, 3, 4]:
    j += i

k += i

print(j)
print(k)
 `j += 1` は、`j = j + i` と同じです。
 インデントしている文はループが実行されていますが、その下のインデントがされていない文はループが実行されていません。
 したがって、`j` は `1 + 2 + 3 + 4` の値が格納されますが、`k` はループの最後に `i` がとる値、`4` のみが格納されます。
 また、特に理由のないインデントは、エラーになります。

# 1

# 'a'

 もちろん、インデントがない場合もエラーになります。

# for i in [1, 3 ,4]

# print(i)

 `for i in [1, 2, 3]` は `range` 型を使って、 `for i in range(1, 4)` でも実行できます。
 `range` 型は `range(b)` とした場合、`0` から `b - 1` までの値を順に返します。
 `range(a, b)` のときは、`a` から `b - 1` までです。
for i in range(4):
    print(i)

for i in range(1, 4):
    print(i)

### while

 `while` は指定した条件式が真の場合にループ文を実行し、条件式が偽になるとループをやめます。
 例えば、次のようにします。
i = 0
while i < 5:
    print(i)
    i += 1

 上の文は `i` が 5 より小さい場合という条件式が真の場合にループ文を実行するということです。
 また、ループ文の最後に `i` の値に 1 を足しています。
 `while` は終わらないループを繰り返すことにもなりかねないので、注意しましょう。
 ループが終わらない場合は、 ■ を押すか、`Ctrl + C` でコードの実行を中止しましょう。

## 条件分岐

 条件分岐は `if` で行えます。
 実行文はインデントで字下げします。
 次のような形になります。

     if [条件式]:
         実行文

a = 0
if a == 0:
    print('True')

 `elif` によって複数の条件分岐ができます。
 上から条件式を満たすかが判断されていきます。
 `else` は、`if` と `elif` を満たさなかった場合のみ実行されます。
a == 3
if a == 1:
    print('1')

elif a == 2:
    print('2')

else:
    print('other')

## 関数

 何度も同じような操作を何度も使うには、関数を用いましょう。
 関数を使うと、操作を再利用することができます。
 関数は次のように `def` を使って定義します。
def return_2():
    x = 2
    return x

return_2()
 ループ文の場合と同じで、関数の定義もインデントして書きます。
 引数をもつ関数を定義するには引数を `()` 内で指定します。
def multiple_2(x):
    x2 = x * 2
    return x2

multiple_2(3)
 関数によって返される戻り値は `return` で指定します。
 `return` の下は実行されないので、注意してください。
def with_print():
    x = 2
    print('above return')
    return x
    print('under return')

with_print()
 引数の数を任意にすることも可能です。
 引数に `*args` を入れると、指定した数以上の引数は `args` にタプルとして格納されます。
 また、引数に `**kwargs` を入れると、指定した数以上の `key=value` という引数は `kwargs` に辞書として格納されます。
def multi_arg(*args):
    print(args)

multi_arg(1, 2, 3)
def multi_kwargs(**kwargs):
    print(kwargs)

multi_kwargs(a=1, b=2)

### 無名関数

 `def` とは違い、簡単にかける無名関数というものあります。`lambda x: function` とすることで無名関数を作成できます。
f = lambda y: y * 2
f(2)

### スコープ

 関数内で変数を定義しても、関数外で参照することはできません。見てみましょう。
def local_x():
    who_am_I = 'local variable'
    print(who_am_I)

local_x()

# who_am_I

 確かに関数内では変数を定義しているし、関数内では参照できているのですが、関数外では参照することができませんでした。
 変数や関数を参照できる範囲を **スコープ** と呼びます。
 関数内で定義した変数を **ローカル変数** といいます。ローカル変数のスコープは定義された変数の中になります。
 一方、いままで定義していた変数は **グローバル変数** といいます。こちらは関数内外で参照することができます。
I_am = 'global variable'
I_am
def ref_global():
    print(I_am)

ref_global()
 さて、こうしたローカル変数およびスコープというものがあると何が嬉しいのでしょうか。
 一つは、関数の影響を最小限にとどめられるということです。
 例えば、関数の中と外で `x` という変数を定義していて、
 関数を呼び出すたびに `x` の値が書き換わっていたらどうでしょうか。
 変数を定義するたびに、関数の中の変数もチェックして、変数名が被っていないかを考えなくてはいけません。
 数行程度ならばできるでしょうが、数百、数千行のコードとなると、全ての変数名を把握するのは難しいでしょう。
 ローカル変数は参照の範囲をあえて狭めることによって、そういったことを防ぐ役割を果たすのです。

## モジュールのインポート

 Python を起動したときにすでにいくつかの型、関数を使うことができます（これらを組み込み型、組み込み関数といいます）。
 R を使ったことがある人はおなじみかも知れませんが、R では `library` を使うことによって、使える型、関数を追加することができます。
 Python では、モジュールを追加するには、`import` を使います。
 ここでは、時間に関する操作に役立つ、`datetime` モジュールを使えるようにしてみましょう。
import datetime
 無事追加できた場合には、特になにも結果がでません。
 存在しないモジュールを追加しようとした場合には、エラーが返ってきます。

# import datetime_time

 `datetime` モジュールには、様々なデータ型が用意されています。
 モジュールから特定の部分のみを追加したい場合は、`from モジュール名 import 名前` とします。
from datetime import timedelta
 追加したモジュールの関数を使いたい場合は、`モジュール名.名前` で使用できます。
 それでは、`datetime` 型を作ってみましょう。
 `datetime` 型は `datetime(year, month, day, minute, second)` のように作成します（最後の 2 つは省略可能です）。
today = datetime.datetime(2017, 9, 11)
 追加するモジュール名が長くて、いちいち打つのが面倒な場合、 `import モジュール名 as 適当な名前` とすれば、指定した名前でモジュールを呼び出せます。
import datetime as dt
dt.datetime(2017, 9, 11)

## 属性 (Attribute)

 あるオブジェクトを作成した場合、そのオブジェクトには固有の変数が追加されることがあります。
 その変数を属性といいます。
 例えば、`datetime`型の属性は、`year`, `month`, `day`, `mitute`, `second` などです。
 属性を呼び出すには、`オブジェクト.属性名` とします。
 メソッドと違うのは、属性は関数ではなく、変数であるということです。
 なので、`()` といった引数は無用です。
today = datetime.datetime(2017, 9, 11)
today.year
today.month

## 組み込み関数

 最後に、Python の組み込み関数を少し見てみましょう。
 完全な一覧は [ドキュメント](https://docs.python.jp/3/library/functions.html) を参照してください。

### type: 型を調べる

 ある変数やモジュールの一部がデータ型なのか関数なのか、よくわからない場合は、`type` を使います。
type(1)
b = [1, 3]
type(b)
def func_type():
    print(1)

type(func_type)

### len: データ型の長さを調べる

 リストやタプル、文字列の長さを調べるときに使います。
len([3, 5])
three = 'three'
len(three)

### データ型を作る

 `int`, `float`, `str`, `list`, `tuple`, `dict` などは、指定の型に変換します。
 ただし、例えば文字列を整数型に変換することはできないなどの規則があります。

# 小数点型 -> 整数型

int(4.6)

# 整数型 -> 小数点型

float(4)

# 文字列型 -> リスト

list('string')

# 文字列型 -> タプル

tuple('string')

# リスト -> 辞書型

dict([['apple', 100], ['melon', 1000]])

# リスト -> タプル

tuple([1, 3, 5])

# リスト -> 文字列型

str([1, 3, 5])

# タプル -> 辞書型

dict((('apple', 100), ('melon', 1000)))

# タプル -> リスト

list((1, 2, 3))

# タプル -> 文字列型

str((1, 2, 3))

# 辞書 -> リスト

list({'apple': 100, 'melon': 10000})

# 辞書 -> タプル

tuple({'apple': 100, 'melon': 10000})

# 辞書 -> 文字列型

str({'apple': 100, 'melon': 10000})
